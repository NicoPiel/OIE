plugins {
    id 'java'
    id 'java-library'
    id 'application'
}

dependencies {
    // --- Project Dependencies ---
    // Depends on Donkey model (published by :donkey)
    implementation project(':donkey') // Assumes standard java-library publication from :donkey
    // Or if donkey publishes specific artifacts:
    // implementation project(path: ':donkey', configuration: 'modelElements') // Need config from :donkey

    // Depends on artifacts published by :server
    // Try standard project dependency first - let Gradle resolve the right configuration
    implementation project(':server')
    
    // If specific artifacts are needed from server, uncomment one of these approaches:
    // implementation project(path: ':server', configuration: 'default')
    // runtimeOnly project(path: ':server', configuration: 'clientCoreElements')
    // runtimeOnly project(path: ':server', configuration: 'cryptoElements')

    // Reflections
    implementation 'org.reflections:reflections:0.9.10'
}

// Configure the standard JAR task to build the library part (mirth-cli.jar)
tasks.named('jar', Jar) {
    archiveBaseName = 'mirth-cli' // Match Ant artifact name
    archiveClassifier = null      // No classifier for the library JAR
    destinationDirectory = layout.buildDirectory.dir('libs-temp') // Output to temp dir

    from(sourceSets.main.output) {
        // Exclude the launcher classes
        exclude 'com/mirth/connect/cli/launcher/**'
    }
}

// Create a custom task for the launcher JAR (mirth-cli-launcher.jar)
tasks.register('launcherJar', Jar) {
    dependsOn processResources, classes // Depend on compiled classes
    archiveBaseName = 'mirth-cli-launcher'
    archiveVersion = ''
    destinationDirectory = layout.buildDirectory.dir('libs-temp') // Output to temp dir

    from(sourceSets.main.output) {
        // Include *only* the launcher classes
        include 'com/mirth/connect/cli/launcher/**'
    }
    manifest {
        attributes(
            'Main-Class': 'com.mirth.connect.cli.launcher.CommandLineLauncher'
            // No Class-Path needed - application plugin handles runtime classpath
        )
    }
}

application {
    // Set the main class for the application plugin (run task, distribution scripts)
    mainClass = 'com.mirth.connect.cli.launcher.CommandLineLauncher'
    // Set executable name if desired (defaults based on project name 'command')
    // applicationName = 'mirth-cli'
}

// Configure the distribution
distributions {
    main { // The default distribution created by the application plugin
        distributionBaseName = 'mirth-cli' // Name of the zip/tar file
        contents {
            // Copy the library JAR into the distribution's lib folder
            into('lib') { // Changed from 'cli-lib' to standard 'lib'
                from(jar) // Add the main library JAR task output
                // Dependencies are automatically included here by the plugin
            }
            // Copy the launcher JAR into the distribution's lib folder
            into('lib') {
                 from(launcherJar) // Add the launcher JAR task output
            }
            // Copy configuration files into the distribution's conf folder
            into('conf') {
                from(sourceSets.main.resources) {
                   include '*.properties' // Include properties files from resources
                }
            }
            // Copy startup scripts (generated by application plugin)
            // into('bin') { // Default location
            // }
        }
    }
}

// Make sure the distribution includes the custom launcher JAR
tasks.named('startScripts') {
    // The application plugin automatically figures out the classpath
    // including all jars in the distribution's 'lib' folder.
    // We just need to ensure the launcher JAR *is* the main jar if needed,
    // but typically setting mainClassName is enough.
    // If the launcher JAR needs to be explicitly set:
    // Jar mainJarTask = tasks.named('launcherJar').get()
    // classpath = files(mainJarTask.archiveFile) + configurations.runtimeClasspath // Complex way
    // Let's rely on the standard behavior first.
}


// Clean task (inherits default behavior, add specifics if needed)
// tasks.named('clean', Delete) {
//     delete layout.buildDirectory.dir('libs-temp')
// }

// Ensure the custom JARs are built before the distribution is assembled
tasks.distTar.dependsOn(jar, launcherJar)
tasks.distZip.dependsOn(jar, launcherJar)

// Build depends on distribution assembly
tasks.build.dependsOn(tasks.distTar, tasks.distZip)

// Testing configuration (inherited from root)
tasks.named('test', Test) {
   // Add specific test config for command/cli if needed
}